<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<body></body>
    <div id="desktop"><span>Use Desktop</span></div>

    <div id="float-top-right" class="hidden">
      <div id="volume" class="togglerContainer">
        <div class="toggler">
          <div class="switchContainer switchOn" id="switchContainer">
            <div class="switchBtn"></div>
          </div>
          <div class="music-score">
            <svg viewBox="0 0 640 640" width="43" height="43" version="1.0" xmlns="http://www.w3.org/2000/svg">
              <g fill="currentColor" stroke="none">
              <path d="M285.74 412.18C250.65 398 236.37 400.96 209.88 406.7C184.57 411.93 159.27 430.32 148.13 451.07C127.88 489.03 138.01 537.79 170.57 558.71C216.29 587.9 284.61 582.52 322.06 549.96C336.5 536.49 347.82 507.92 349.44 501.18C351.18 490.7 352.02 481.65 351.93 474.04L351.93 317.66L351.93 154.68C353.81 154.55 357.02 154.55 361.56 154.68C368.37 154.89 371.98 155.44 374.71 155.99C421.78 165.78 433.62 186.55 440.62 227.92C441.1 231.46 441.66 237.91 442.3 247.27L461.09 247.27L502.31 247.27C501.98 230.55 501.31 217.42 500.29 207.88C498.44 181.91 497.86 159.25 469.47 122.81C460.19 111 441.04 96.21 427.2 89.46C407.97 80.18 386.19 72.83 351.93 68.48C317.68 64.14 314.33 63.47 308.09 63.13C307.32 63.1 299.87 62.79 285.74 62.21L285.74 245.07C287.54 357.26 287.54 412.96 285.74 412.18Z"></path>
              </g>
            </svg>
          </div>
          <div class="music-score-slash"></div>
      
      
        </div>
      </div>
    </div>
<body>
<div id="app" >
<div id="mobile" class="wrapper">


  <div id="stages">
<div class="stage wrapper active">
  
  
  <div class="mobile layer-1">
    
          <background>
            <cover></cover>
          </background>
    
    
          <block drag="40" flex-1 style="clip-path: url(#cover-wave);-webkit-clip-path: url(#cover-wave);background-color: #FAC668;height:100%;width:100%;">
            <div flex-3 >
            </div>
            <div drag="40" flex-vert-center flex-5 width-100p left-align left-margin-small>
              <p font-large en="EXPLORE
YOUR
JOURNEY" zh="探索你的旅程"></p>
            </div>
            <div drag="40" flex-2 width-100p left-align left-margin-small>
              <p en="Test your inner values" zh="透視你的內心世界"></p>
            </div>
            <div flex-1>
              <span></span> 
            </div>
          </block>
  
  
  
Hi!</div>
  <div curtain-config="{reversible:false}" class="mobile layer-2">This is page . No going back to page 1!</div>
  <div curtain-config="{reversible:true}" class="mobile layer-3">This is page 3, Swipe right to go back to page 2</div>
  <div curtain-config="{reversible:true}" class="mobile layer-4">This is page 4</div>
  <div curtain-config="{reversible:true}" class="mobile layer-5">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-6">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-7">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-8">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-9">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-10">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-11">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-12">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-13">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-14">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-15">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-16">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-17">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-18">This is page 5</div>
  <div curtain-config="{reversible:true}" class="mobile layer-19">This is page 5</div>
  <!--
-->
  
</div>

  <svg class="clippath" full-width-abs full-height-abs viewbox="0 0 100 100">
    <clipPath id="cover-wave" clipPathUnits="objectBoundingBox">
      <path fill="#000" viewbox="0 0 100 100" width='100%' height='100%'  d="M 0 0.175 C 0.150 0.250 0.300 0.250 0.300 0.250 C 0.550 0.250 0.630 0.01 1 0 L 1 1 L 0 1 z "></path>
    </clipPath>
  </svg>


  <style>* {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -ms-touch-action: manipulation;
    touch-action: manipulation;
  }
  
  body {
    touch-action: none;
    margin: 0;
    height: 100vh;
    height: calc(var(--vh, 1vh) * 100);
    background-color: papayawhip;
    overflow: hidden;
  }
  
  .svg-circles {
    fill: #D62300;
  }
  
  .round {
    stroke-linejoin: round;
  }
  
  .curtain-1 {
    pointer-events: none;
    position: absolute;
    z-index: 999;
    left: 0;
    top: 0;
    transform-origin: top left;
  }
  
  .wrapper {
    width: 100%;
    height: 100%;
    display: flex;
  }
  
  .mobile {
    position: absolute;
    width: 100%;
    height: 100%;
    display: flex;
    left: 0;
    top: 0;
    padding: 30px;
  }
  
  .layer-1 {
    background-color: #77f;
  }
  
  .layer-2 {
    background-color: #7f7;
  }
  
  .layer-3 {
    background-color: #ff7;
  }
  
  .layer-4 {
    background-color: #f77;
  }
  
  .layer-5 {
    background-color: #7ff;
  }
  
  .layer-6 {
    background-color: #77f;
  }
  
  .layer-7 {
    background-color: #7f7;
  }
  
  .layer-8 {
    background-color: #ff7;
  }
  
  .layer-9 {
    background-color: #f77;
  }
  
  .layer-10 {
    background-color: #7ff;
  }
  
  .layer-11 {
    background-color: #7ff;
  }
  
  .layer-12 {
    background-color: #7f7;
  }
  
  .layer-13 {
    background-color: #ff7;
  }
  
  .layer-14 {
    background-color: #f77;
  }
  
  .layer-15 {
    background-color: #7ff;
  }
  
  .layer-16 {
    background-color: #77f;
  }
  
  .layer-17 {
    background-color: #7f7;
  }
  
  .layer-18 {
    background-color: #ff7;
  }
  
  .layer-19 {
    background-color: #f77;
  }
  
  .curtain {
    pointer-events: none;
    position: absolute;
    z-index: 999;
    left: 0;
    top: 0;
    -webkit-transform-origin: top left;
    transform-origin: top left;
  }
  
  .arrow {
    position: absolute;
  }
  
  * {
    box-sizing: border-box;
    user-select: none;
    touch-action: manipulation;
    /*
    -webkit-tap-highlight-color:transparent;
    backface-visibility: hidden;
    transform: translate3d(0, 0, 0);
    perspective: 1000;
    */
    opacity: 1;
  }
  
  .scrollable {
    /*@include scrollbars(.5em, slategray);*/
    overflow: overlay;
  }
  
  .scrollable.modern-scrollbar {
    background-color: white !important;
  }
  .scrollable.modern-scrollbar::-webkit-scrollbar {
    height: 16px;
    width: 16px;
    background: transparent;
    border-radius: 50%;
  }
  .scrollable.modern-scrollbar::-webkit-scrollbar-thumb {
    background: #ddd;
    border: 6px solid white;
    border-radius: 20px;
  }
  
  .show-children-slowly > * {
    opacity: 0;
  }
  .show-children-slowly.active > * {
    opacity: 1;
  }
  .show-children-slowly.active > *:nth-child(1) {
    transition: 0.48s cubic-bezier(0.62, 0.02, 0.34, 1) 0.4s;
  }
  .show-children-slowly.active > *:nth-child(2) {
    transition: 0.56s cubic-bezier(0.62, 0.02, 0.34, 1) 0.5s;
  }
  .show-children-slowly.active > *:nth-child(3) {
    transition: 0.64s cubic-bezier(0.62, 0.02, 0.34, 1) 0.6s;
  }
  .show-children-slowly.active > *:nth-child(4) {
    transition: 0.72s cubic-bezier(0.62, 0.02, 0.34, 1) 0.7s;
  }
  .show-children-slowly.active > *:nth-child(5) {
    transition: 0.8s cubic-bezier(0.62, 0.02, 0.34, 1) 0.8s;
  }
  .show-children-slowly.active > *:nth-child(6) {
    transition: 0.88s cubic-bezier(0.62, 0.02, 0.34, 1) 0.9s;
  }
  .show-children-slowly.active > *:nth-child(7) {
    transition: 0.96s cubic-bezier(0.62, 0.02, 0.34, 1) 1s;
  }
  .show-children-slowly.active > *:nth-child(8) {
    transition: 1.04s cubic-bezier(0.62, 0.02, 0.34, 1) 1.1s;
  }
  .show-children-slowly.active > *:nth-child(9) {
    transition: 1.12s cubic-bezier(0.62, 0.02, 0.34, 1) 1.2s;
  }
  .show-children-slowly.active > *:nth-child(10) {
    transition: 1.2s cubic-bezier(0.62, 0.02, 0.34, 1) 1.3s;
  }
  
  :root {
    touch-action: none;
    height: 100%;
  }
  
  html {
    background: #547a41;
  }
  
  body, html {
    overscroll-behavior-y: contain;
    overscroll-behavior-x: none;
    touch-action: none;
    overflow: hidden;
    font-family: 'Noto Sans TC', sans-serif;
    margin: 0;
    padding: 0;
    height: 100vh;
    width: 100vw;
    height: calc(var(--vh, 1vh) * 100);
    box-shadow: 0 0 35px #0009;
  }
  
  p {
    white-space: pre;
    margin: 0;
  }
  
  block {
    flex-direction: column;
  }
  
  #assets {
    display: none;
  }
  
  .clippath {
    pointer-events: none;
    position: absolute;
    z-index: 999;
    left: 0;
    top: 0;
  }
  
  [flex-vert-center] {
    display: flex;
    align-items: center;
  }
  
  [flex-1] {
    flex: 1;
    display: flex;
  }
  
  [flex-2] {
    flex: 2;
    display: flex;
  }
  
  [flex-3] {
    flex: 3;
    display: flex;
  }
  
  [flex-4] {
    flex: 4;
    display: flex;
  }
  
  [flex-5] {
    flex: 5;
    display: flex;
  }
  
  [flex-6] {
    flex: 6;
    display: flex;
  }
  
  [width-100p] {
    width: 100%;
  }
  
  [left-align] {
    text-align: left;
    margin-right: auto;
  }
  
  [right-align] {
    text-align: right;
  }
  
  [middle-align] {
    text-align: center;
  }
  
  [left-margin-small] {
    margin-left: 2em;
  }
  
  [margin-auto] {
    margin: auto;
  }
  
  [font-large] {
    font-size: 2em;
  }
  
  #desktop {
    position: absolute;
    left: 0;
    z-index: 99999;
    display: none;
    background: white;
    width: 100%;
    height: 100%;
    vertical-align: middle;
    align-items: center;
  }
  @media all and (min-width: 768px) {
    #desktop {
      display: flex;
    }
  }
  
  #desktop > span {
    display: inline-block;
    position: relative;
    vertical-align: middle;
    margin: auto;
    flex-direction: column;
  }
  
  .wrapper {
    display: flex;
    position: absolute;
    top: 0;
    left: 0;
    flex-direction: column;
    margin: auto;
    height: 100%;
    width: 100%;
    vertical-align: middle;
    align-items: center;
  }
  .wrapper > * {
    /*
    flex: 1;
    text-align: center;*/
    align-items: center;
    display: flex;
    width: 100%;
  }
  
  .display-none {
    display: none;
  }
  
  .hidden {
    opacity: 0;
    pointer-events: none;
  }
  
  .thin-body {
    max-width: 75%;
  }
  
  #app {
    overflow: hidden;
    position: relative;
    height: 100%;
    width: 100%;
    height: calc(var(--vh, 1vh) * 100);
  }
  
  #mobile {
    vertical-align: middle;
    align-items: center;
    background: #fdd;
    height: 100%;
    width: 100%;
  }
  
  #stages {
    vertical-align: middle;
    align-items: center;
    background: #fdd;
    height: 100%;
    width: 100%;
  }
  #stages > * {
    position: absolute;
  }
  
  #loading-wrapper {
    position: absolute;
    background: white;
    z-index: 999;
  }
  #loading-wrapper > div {
    margin: auto;
  }
  #loading-wrapper > div > span {
    width: 50px;
  }
  
  #float-top-right {
    position: absolute;
    top: 0;
    right: 0;
    transition: 0.45s cubic-bezier(0.62, 0.02, 0.34, 1) 0.3s;
    z-index: 999;
  }
  
  /*
  
    Stages
  
  */
  background {
    width: 100%;
    height: 100%;
    position: absolute;
  }
  
  cover {
    background: url(https://img.freepik.com/free-vector/sky-background-video-conferencing_23-2148621414.jpg?size=626&ext=jpg);
    background-position-x: center;
    background-repeat: no-repeat;
    background-size: cover;
    height: 100%;
    width: 100%;
    display: flex;
  }
  
  #intro #intro-start {
    margin: auto;
    flex: 2;
  }
  
  #intro-tran #intro-tran-text {
    flex: 4;
  }
  #intro-tran #intro-tran-start {
    margin: auto;
    flex: 1;
  }
  #intro-tran #intro-tran-footer {
    flex: 2;
  }
  
  #debug {
    display: block;
    position: absolute;
    z-index: 999999999;
    background: #5554;
  }
  
  #lang-switcher > span {
    padding: 0.5em;
  }
  
  *:not(input):not(textarea) {
    -webkit-user-select: none;
    /* disable selection/Copy of UIWebView */
    -webkit-touch-callout: none;
    /* disable the IOS popup when long-press on a link */
  }
  
  .cards {
    text-align: left;
  }
  </style>

  <script>
    var makeCurtain = (function () {
      var ua = window.navigator.userAgent;
      var iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
      var webkit = !!ua.match(/WebKit/i);
      var iOSSafari = iOS && webkit && !ua.match(/CriOS/i);
    
      const map = (value, inMin, inMax, outMin, outMax) => {
        return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
      };
    
      const pointsPositionsCalc = (points, w, h, options) => points.map(e => {
        const x = map(e[0], options.xMin, options.xMax, 0, w)
        const y = map(e[1], options.yMin, options.yMax, h, 0)
        return [x, y]
      })
    
      const svgCircles = points => points.reduce((acc, point, i, a) =>
        `${acc} <circle cx="${point[0]}" cy="${point[1]}" r="2.5" class="svg-circles" v-for="p in pointsPositions"/>`, '')
    
      const prec = 2;
    
      /*creates formated path string for SVG cubic path element*/
      function path(x1,y1,px1,py1,px2,py2,x2,y2)
      {
        return x1.toFixed(prec)+" "+y1.toFixed(prec)+" C "+px1.toFixed(prec)+" "+py1.toFixed(prec)+" "+px2.toFixed(prec)+" "+py2.toFixed(prec)+" "+x2.toFixed(prec)+" "+y2.toFixed(prec);
      }
     
    
      /*computes control points given knots K, this is the brain of the operation*/
      function computeControlPoints(K)
      {
        var p1=new Array();
        var p2=new Array();
        var n = K.length-1;
        var m;
    
        /*rhs vector*/
        var a=new Array();
        var b=new Array();
        var c=new Array();
        var r=new Array();
    
        /*left most segment*/
        a[0]=0;
        b[0]=2;
        c[0]=1;
        r[0] = K[0]+2*K[1];
    
        /*internal segments*/
        for (var i = 1; i < n - 1; i++)
        {
          a[i]=1;
          b[i]=4;
          c[i]=1;
          r[i] = 4 * K[i] + 2 * K[i+1];
        }
    
        /*right segment*/
        a[n-1]=2;
        b[n-1]=7;
        c[n-1]=0;
        r[n-1] = 8*K[n-1]+K[n];
    
        /*solves Ax=b with the Thomas algorithm (from Wikipedia)*/
        for (i = 1; i < n; i++)
        {
          m = a[i]/b[i-1];
          b[i] = b[i] - m * c[i - 1];
          r[i] = r[i] - m*r[i-1];
        }
    
        p1[n-1] = r[n-1]/b[n-1];
        for (i = n - 2; i >= 0; --i)
          p1[i] = (r[i] - c[i] * p1[i+1]) / b[i];
    
        /*we have p1, now compute p2*/
        for (i=0;i<n-1;i++)
          p2[i]=2*K[i+1]-p1[i+1];
    
        p2[n-1]=0.5*(K[n]+p1[n-1]);
    
        return {p1:p1, p2:p2};
      }
      
      /*computes spline control points*/
      function updateSplines(V)
      {	
        /*grab (x,y) coordinates of the control points*/
        var L = V.length;
        var x=new Array();
        var y=new Array();
        for (var i=0;i<L;i++)
        {
          /*use parseInt to convert string to int*/
          x[i]=V[i][0]
          y[i]=V[i][1]
        }
    
        /*computes control points p1 and p2 for x and y direction*/
        var px = computeControlPoints(x);
        var py = computeControlPoints(y);
    
        /*updates path settings, the browser will draw the new spline*/
        var ret = []
        for (i=0;i<L-1;i++)
              ret.push(path(x[i],y[i],px.p1[i],py.p1[i],px.p2[i],py.p2[i],x[i+1],y[i+1]))
    
        return "M "+ret.join(' L ') +" Z"
      }
    
    
      const svgPath = (points) => {
        const D = updateSplines(points);
        return D
      }
      
      
      var pointerEventToXY = function(e){
        var out = {x:0, y:0};
        if(e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel'){
          var touch = e.originalEvent?(e.originalEvent.touches[0] || e.originalEvent.changedTouches[0]):e.changedTouches[0];
          out.x = touch.pageX;
          out.y = touch.pageY;
        } else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover'|| e.type=='mouseout' || e.type=='mouseenter' || e.type=='mouseleave') {
          out.x = e.pageX;
          out.y = e.pageY;
        }
        return out;
      };
      
    
      function min(a, b) {
        return a > b ? b : a;
      }
    
      function max(a, b) {
        return a > b ? a : b;
      } 
    
      function lerp(min, max, fraction) {
        return (max - min) * fraction + min;
      }
    
      var vh;
      var vw;
      var height;
      var width;
    
      function update_vh() {
        height = window.innerHeight;
        width = window.innerWidth;
        vh = window.innerHeight * 0.01;
        vw = window.innerWidth * 0.01;
      }
      update_vh();
      var onresize = function (event) {
        update_vh();
      };
      if (window.attachEvent) {
        window.attachEvent('onresize', onresize);
      } else if (window.addEventListener) {
        window.addEventListener('resize', onresize, true);
      }
    
    
      var index = 0;
      var debug = false; 
      let but_drag = 1.2;
      let but_size = 50;
      let right_pad = 6;
      let smoothing = 0.15;
      let but_horiz_offset = 0.9;
      let but_horiz_offset2 = 1.3;
      let but_over_ratio = 1;
      let but_over_ratio2 = 1;
      var far_v = 60;
      let friction = 0.09;
      var defaults = {
        start_ended: true,
        closed: false,
        start: false,
        closing: true,
        reversible: true,
        but_y_pos: 0.25,
        startX: right_pad + but_size * but_horiz_offset * 3,
        startY: right_pad + but_size * but_horiz_offset,
    
    
        next: function (self) {
          var obj = self.obj
          setTimeout(function () {
            var nextCurtain = obj.querySelector('.curtain-page');
            if (nextCurtain)
              nextCurtain.curtain.show();
    
          }, self.opened ? 0 : 500);
        }
    
    
      }
    
      function makeCurtain(obj, config) {
        config = config || {}
        var ns = 'http://www.w3.org/2000/svg';
        index += 1
        var current_index = index;
        var curtain_id = "curtainClip-" + index;
        var arrow = document.createElement('span');
        arrow.classList.add('arrow');
        var curtain = document.createElementNS(ns, 'svg');
        var path_dom = document.createElementNS(ns, 'path');
        var clipPath = document.createElementNS(ns, 'clipPath');
        var but_y_pos_actual;
        clipPath.id = curtain_id;
        curtain.appendChild(clipPath);
        curtain.appendChild(document.createElementNS(ns, 'g'));
        clipPath.appendChild(path_dom);
        path_dom.setAttribute('fill', '#9300bb');
        curtain.classList.add('curtain');
        document.body.appendChild(curtain);
    
        document.body.appendChild(arrow);
        var self = Object.assign({}, defaults, config);
        self.curtain = curtain;
        self.path_dom = path_dom;
        self.endX = self.startX;
        self.endY = self.startY;
        self.mousedown = false;
        obj.style.clipPath = "url(#" + curtain_id + ")";
        obj.style.webkitClipPath = "url(#" + curtain_id + ")";
        var clipPathEnabled = false;
        const enableClipPath = function(){
          if (clipPathEnabled)
            return;
          var value = "url(#" + curtain_id + ")";
          obj.style.clipPath = value;
          obj.style.webkitClipPath = value;
          clipPathEnabled = true;
        }
        const disableClipPath = function(){
          if (!clipPathEnabled)
            return;
          obj.style.clipPath = "";
          obj.style.webkitClipPath = "";
          clipPathEnabled = false;
        }
        enableClipPath();
        if (self.closed) {
          self.startX = 0;
          self.startY = 0;
          self.endX = 0;
          self.endY = 0;
    
        }
    
        obj.curtain = self;
        self.obj = obj
    
        setTimeout(function (e) {
          self.start_ended = true;
        }, 1000);
    
    
        curtain.setAttribute("width", width);
        curtain.setAttribute("height", height);
        curtain.setAttribute("viewbox", `0 0 ${width} ${height}`);
    
        self.x = self.startX, self.y = self.startY;
        self.x2 = right_pad * 2, self.y2 = self.startY;
        self.x3 = right_pad * 2, self.y3 = self.startY;
        self.x4 = right_pad * 2, self.y4 = self.startY;
        self.x5 = right_pad * 2, self.y5 = self.startY;
    
        function update() {
          try{
          var deltaX = (self.endX - self.startX);
          var deltaY = (self.endY - self.startY);
          var stable = Math.abs(deltaX - self.x) < 1e-5;
    
          if (self.start_ended) {
            if (deltaX > 0)
              deltaX = 0;
          }
          but_y_pos_actual = height * (1 - self.but_y_pos);
          var deltaY_max = max(0, height - but_y_pos_actual - but_size * 2.5);
          if (deltaY > deltaY_max)
            deltaY = deltaY_max
          var deltaY_min = min(0, -but_y_pos_actual + but_size * 2.5);
          if (deltaY < deltaY_min)
            deltaY = deltaY_min;
    
            
          if (!self.start && self.x > -1) {
            //requestAnimationFrame(update);
            //path_dom.setAttribute('d', "");
            //return; 
            deltaX = 60;
          }
          if (deltaX < -width / but_over_ratio - 5)
            deltaX = -width / but_over_ratio - 5;
    
          self.x = lerp(self.x, deltaX, friction);
          self.y = lerp(self.y, deltaY, friction);
          if (!self.start && self.x >= right_pad + but_size ){ 
            obj.style.display = 'none';
              if (self.x < -width+5 && self.closing)
                disableClipPath()
            requestAnimationFrame(update);
            return;
          }else if ((self.x < -width && !self.mousedown) || stable){
              if (self.x < -width+5 && self.closing)
                disableClipPath()
            requestAnimationFrame(update);
            return;
            
          }else if (obj.style.display == 'none'){
            obj.style.display = '';
          }
          
          enableClipPath();
    
          var but_y = but_y_pos_actual + self.y;
    
          var follow_speed = 6;
    
          var percent_done_real = -self.x / width;
          if (percent_done_real < 0) percent_done_real = 0; 
          if (percent_done_real > 1) percent_done_real = 1;
          var percent_done = -self.x / min(500, width);
          if (percent_done < 0) percent_done = 0;
          if (percent_done > 1) percent_done = 1;
          percent_done = percent_done_real
          
          var far = percent_done * far_v;
          
          self.x2 = lerp(self.x2, min(
            (self.x < -width ? -width : self.x), right_pad * 10), friction * 6); 
          self.x3 = lerp(self.x3, min(
            (self.x2 < -width ? -width : self.x2) * mix(self.closing ? 0.1 : 1, 1, percent_done_real, 0.2, 1.0), right_pad * 10), friction * follow_speed);
          self.x4 = lerp(self.x4, min(
            ((self.x3 < -width ? -width : self.x3)) * mix(self.closing ? 0.1 : 1, 1, percent_done_real, 0.2, 1.0), right_pad * 10), friction * follow_speed);
          self.x5 = lerp(self.x5, min(
            ((self.x4 < -width ? -width : self.x4)) * mix(self.closing ? 0.1 : 1, 1, percent_done_real, 0.2, 1.0), right_pad * 10), friction * follow_speed);
    
          if (self.start || self.x < -60) {
            if (self.x2 < self.x) { 
              self.x2 = self.x;
            }
            if (self.x3 < self.x) {
              self.x3 = self.x;
            }
            if (self.x4 < self.x) {
              self.x4 = self.x;
            } 
            if (self.x5 < self.x) {
              self.x5 = self.x;
            }
    
          }
          self.x5 = self.x4;
    
          function mix(a, b, p, h, k) {
            var d = k - h;
            if (p - h > 0) {
              p = (p - h) / d;
              if (p > 1) p = 1;
              if (p < 0) p = 0;
              return a * (1 - p) + b * p
            }
            return a
          }
    
    
          var but_scale = self.x < 0 ? 10 / (-self.x) ** 0.5 : 1;
          if (but_scale > 1)
            but_scale = 1;
          but_scale = 0.8 + but_scale * 0.2;
    
          var but_offset = but_size * (1 / but_scale) * mix(but_horiz_offset, but_horiz_offset2, percent_done, 0.0, 0.9);
    
          
    
          var mm = 0.06; 
    
          var middle_z4 = but_size / but_scale * but_drag * 2 +
            mix(far * 2, far * 5, percent_done_real, 0.7, 1.0) + far_v * 3 +
            ((self.closing ? 1: 0.25) *mix(far, far * 6, percent_done_real, 0.0, 0.3)) -
            (self.closing ? (mix(mix(0, 130, percent_done_real, 0, mm), 0, percent_done_real, 0, 0.7)) : 0) +
              mix(mix(0,200,percent_done_real,mm,0.5),0,percent_done_real,0.3,0.7);
          var middle_z3 = but_size / but_scale * but_drag * 2 +
            mix(far * 1.2, far *2, percent_done_real, mm, 1.0) +
            mix(far * 2, far * 3, percent_done_real, 0.7, 1.0) + far_v / 3 +
            ((self.closing ? 1: 0.25) * mix(0, far * 6, percent_done_real, 0.0, 1.0)) -
            (self.closing ? (mix(mix(0, 30, percent_done_real, 0, mm), 0, percent_done_real, 0, 0.7)) : 0);
          var middle_z2 = but_size / but_scale * but_drag +
            mix(far * 1.2, far *2, percent_done_real, mm, 1.0) +
            (self.closing ? 1 : 0.3) * mix(0, far * mix(4, 5, percent_done_real, 0.25, 0.85), percent_done_real, 0.0, 1.0) +
            (self.closing ? (mix(mix(0, 17, percent_done_real, 0, mm), 0, percent_done_real, 0, 0.5)) : 0);
          var middle_z = but_size / but_scale / mix(2, 3, percent_done_real, 0, mm) + far ** 0.8 +
            (self.closing ? mix(0, far / 4, percent_done_real, 0.8, 1.0) : 0) +
            (self.closing ? 1 : 0.3) * mix(0, far*2, percent_done_real, 0.0, 1.0) +
            (self.closing ? 1 : 0.6) * mix(mix(0, 13, percent_done_real, 0, mm), 0, percent_done_real, 0, 0.5); 
    
     
          var middle_zx4 = mix(mix(0, self.closing?20:-50, percent_done_real, 0.0, 0.7), 0, percent_done_real, 0.7, 1.0);
          var middle_zx3 = mix(
            mix(0, self.closing ? 50 : -45, percent_done_real, 0, 0.7), 0, percent_done_real, 0.7, 1.0) +
            (self.closing ? 1 : 0) * mix(mix(0, width**1.5 / 1500, percent_done_real, 0, mm), 0, percent_done_real, 0, 1); 
    
          var middle_zx2 = but_size / 7 - mix(mix(0, self.closing?width / 8:30, percent_done_real, mm, 1.0), 0, percent_done_real, 0.7, 1.0) +
            (self.closing ? (mix(mix(0, 9, percent_done_real, 0, mm), 0, percent_done_real, 0, 0.3)) :
              0);
          var middle_zx = width - right_pad - but_offset + self.x;
    
    
          var min_x = (-right_pad - but_offset - 1);
          var min_x_mag = (-(min_x) * 2.5); 
    
          function adjust_x(x) {
            if (!self.closing) {
              return mix(x, x - min_x - right_pad * 2, percent_done_real, 0.3, 0.7);
            }
            
            var offset = 0.045;
            var offset_amount = 2 * (-(offset ** 2) + offset) * min_x_mag;
            if (x < offset_amount) { 
              var p = ((x - offset_amount) / min_x) * ((min_x_mag) /  ( min_x_mag+ offset_amount)) ;
              var ret = 2 * (-(p ** 2) + p) * (min_x_mag)  + offset_amount;
              return ret;
            }
            return x
          }
          var ad_x = adjust_x(middle_zx);
    
          let points = [
            [width + 200, but_y - height - 100],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y - height - 100],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y - height - 100],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y - middle_z4 - mix(500,700,percent_done_real,0,0.6)],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y - middle_z4 - mix(300,500,percent_done_real,0,0.6)],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y - middle_z4 - mix(200,300,percent_done_real,0,0.6)],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y - middle_z4],
            [width - right_pad + self.x4 * but_over_ratio2 - middle_zx3, but_y - middle_z3],
            [width - right_pad - middle_zx2 + self.x2, but_y - middle_z2],
            [ad_x, but_y - middle_z],
            [ad_x, but_y + middle_z],
            [width - right_pad - middle_zx2 + self.x2, but_y + middle_z2],
            [width - right_pad + self.x4 * but_over_ratio2 - middle_zx3, but_y + middle_z3],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y + middle_z4],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y + middle_z4 + mix(100,300,percent_done_real,0,0.6)],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y + middle_z4 + mix(300,500,percent_done_real,0,0.6)],
            [width - right_pad + self.x5 * but_over_ratio2 - middle_zx4, but_y + middle_z4 + mix(500,700,percent_done_real,0,0.6)],
            [width - right_pad + self.x5 * but_over_ratio2, but_y + height + 100],
            [width - right_pad + self.x5 * but_over_ratio2, but_y + height + 100],
            [width + 200, height + 200],
          ];
          var tt = 7,
            L = points.length; 
          var pp = 0.05;
          var nudge = mix(-1, 0, middle_zx, min_x/2, 0) * mix(0, -20, percent_done_real, 0.60, 0.70); 
          if (!self.closing){
            nudge = 0;
          }
          
          if (true) {
            if (points[tt][0] < points[tt + 1][0]) points[tt][0] = points[tt + 1][0];
            points[tt][0] = mix(points[tt][0], points[tt + 1][0] - nudge, percent_done_real, pp, 1.0);
            points[tt - 1][0] = mix(points[tt - 1][0], points[tt + 1][0] - nudge , percent_done_real, pp, 1.0);
            points[tt - 2][0] = mix(points[tt - 2][0], points[tt + 1][0] - nudge, percent_done_real, pp, 1.0);
            points[tt - 3][0] = mix(points[tt - 3][0], points[tt + 1][0] - nudge, percent_done_real, pp, 1.0);
            points[tt - 4][0] = mix(points[tt - 4][0], points[tt + 1][0] - nudge, percent_done_real, pp, 1.0);
            tt = L - tt - 1;
            if (points[tt][0] < points[tt - 1][0]) points[tt][0] = points[tt - 1][0];
            points[tt][0] = mix(points[tt][0], points[tt - 1][0] - nudge, percent_done_real, pp, 1.0);
            points[tt + 1][0] = mix(points[tt + 1][0], points[tt - 1][0] - nudge, percent_done_real, pp, 1.0);
            points[tt + 2][0] = mix(points[tt + 2][0], points[tt - 1][0] - nudge , percent_done_real, pp, 1.0);
            points[tt + 3][0] = mix(points[tt + 3][0], points[tt - 1][0] - nudge , percent_done_real, pp, 1.0); 
            points[tt + 4][0] = mix(points[tt + 4][0], points[tt - 1][0] - nudge , percent_done_real, pp, 1.0);
          }
    
          tt = 8;
          points[tt][0] = points[tt][0] + (self.closing ? 0 : mix(0, mix(4, 0, percent_done, 0, 1), percent_done, 0, 0.3));
          tt = L-tt-1;
          points[tt][0] = points[tt][0] + (self.closing ? 0 : mix(0, mix(4, 0, percent_done, 0, 1), percent_done, 0, 0.3));
    
          
          // points = points.map((e, i)=>[(i>0&&i<points.length-1&&e[0]>width)?width:e[0],height-e[1]])
          points = points.map((e, i) => [e[0], height - e[1]])
    
          const pointsPositions = pointsPositionsCalc(points, width, height, {
            yMin: 0,
            yMax: height,
            xMin: 0,
            xMax: width
          })
          const path = svgPath(pointsPositions);
          var changed = path_dom.getAttribute('d') != path;
          
          if (changed){
            path_dom.setAttributeNS(null,'d', path);
      
            if (true){
              /*
              var temp = document.createElement('div');
              obj.appendChild(temp);
              obj.offsetHeight; 
              temp.remove();
              */
              obj.style.display = 'inline-flex';
              obj.offsetHeight; // no need to store this anywhere, the reference is enough
              obj.style.display = 'flex';
              
            }
            
          }
          
          if (debug)
            curtain.querySelector('g').innerHTML = svgCircles(pointsPositions);
    
          requestAnimationFrame(update);
          
          }catch(err){
            console.error(err);
          }
        }
    
        update();
    
        function moveCurtain(e) {
          if (!self.mousedown) {
            return;
          }
          var pos = pointerEventToXY(e);
          self.endX = pos.x;
          self.endY = pos.y;
        }
        
    
        function between(x, a, b) {
          return x < b && x > a;
        }
    
        var hasBeenTouchedRecently = false;
    
        function startCurtain(e) {
          if(hasBeenTouchedRecently) {
            return;
          }
          hasBeenTouchedRecently = true;
          setTimeout(() => { hasBeenTouchedRecently = false; }, 300);
          e.preventDefault();
          e.stopPropagation();
          
          let _x, _y;
          let path = e.composedPath();
          let next_curtain = self.obj.querySelector('.curtain-page');
          
          if (self.closed || !self.start || (!self.obj.contains(path[0]) || (next_curtain && next_curtain.contains(path[0]))))
            return;
            
          var pos = pointerEventToXY(e);
          _x = pos.x;
          _y = pos.y;
          var opened = self.endX <= -width / 2;
          if (!opened) {
            if (!between(_y, but_y_pos_actual - but_size, but_y_pos_actual + but_size)) {
              return;
            }
            if (!between(_x, width - but_size, width + but_size)) {
              return;
            }
          } else if (_x > 40) {
            return;
          }
          if (opened) {
            var nextCurtain = obj.querySelector('.curtain-page');
            if (nextCurtain)
              nextCurtain.curtain.hide();
          }
          self.closing = !opened;
    
          self.mousedown = true;
          self.startX = opened ? width : _x;
          self.startY = _y;
          
          moveCurtain(e);
          return true;
        }
    
        function show() {
          self.start = true;
          self.closing = true;
        }
    
        function hide() {
          self.start = false;
          self.closing = false;
          self.mousedown = false;
          self.startX = 0;
          self.startY = 0;
          self.endX = 0;
          self.endY = 0;
        }
    
        function endCurtain(e) {
          e.preventDefault();
          e.stopPropagation();
          
          let _x, _y;
          var pos = pointerEventToXY(e);
          _x = pos.x;
          _y = pos.y;
          
          if (!self.mousedown)
            return;
          self.mousedown = false;
          var opened = !self.closing;
          var clicked = self.closing && self.startX == _x && self.startY == _y;
    
          if (clicked || (self.endX - self.startX < (!opened ? -width / 3 : -width * 2 / 3))) {
            self.startX = 0;
            self.endX = -width / but_over_ratio - 3;
            if (self.next)
              self.next(self)
    
            if (!self.reversible)
              self.closed = true;
          } else {
            self.startX = 0;
            self.startY = 0;
            self.endX = 0;
            self.endY = 0;
          }
        }
    
        self.show = show;
        self.hide = hide;
        self.endCurtain = endCurtain;
    
        document.addEventListener('mousedown', (e) => {
          if (startCurtain(e))
            document.addEventListener('mousemove', moveCurtain)
        })
    
        document.addEventListener('mouseup', (e) => {
          endCurtain(e)
          document.removeEventListener('mousemove', moveCurtain);
        })
    
        document.addEventListener('touchstart', startCurtain);
        document.addEventListener('touchend', function (e) {
          endCurtain(e)
        });
    
        document.addEventListener('touchmove', moveCurtain, { passive: false });
    
        return self;
    
      }
      return makeCurtain;
    })();
    
    function makeCurtains(wrapper) {
      var children = Array.from(wrapper.children);
      children.reverse();
    
      children.forEach((e, i) => {
        if (children[i + 1]) {
          var config = e.getAttribute('curtain-config') || "{}";
          config = eval('(' + config + ')');
          children[i + 1].appendChild(e);
          e.classList.add('curtain-page')
          makeCurtain(e, config);
          if (i == children.length - 2) {
            e.curtain.show();
          } else {
            e.curtain.hide();
    
          }
        }
      });
    
    }
    
    function update_vh() {
      let height = window.innerHeight;
      let width = window.innerWidth;
      let vh = height * 0.01;
      let vw = width * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
      document.documentElement.style.setProperty('--vw', `${vw}px`);
      if (width > BODY_MAX_WIDTH){
        document.body.style.width = BODY_MAX_WIDTH+"px"
        document.body.style.marginLeft = parseInt((width - BODY_MAX_WIDTH) /  2) + 'px';
        width = BODY_MAX_WIDTH;
    
      }else{
        document.body.style.width = ""
        document.body.style.marginLeft =  '';
      }
      
      document.documentElement.style.setProperty('--window-height', `${height}`);
      document.documentElement.style.setProperty('--window-width', `${width}`);
      document.querySelectorAll('[full-width-abs]').forEach(e=>{
        if (e.tagName == "svg")
          e.setAttribute("width", width);
        else
          e.style.width = width + 'px';
      })
      document.querySelectorAll('[full-height-abs]').forEach(e=>{
        if (e.tagName == "svg")
          e.setAttribute("height", height);
        else
          e.style.height = height + 'px';
      })
    
      window.dispatchEvent(new Event('curtain-resize'));
      
    }
    var onresize = function (event) {
      update_vh();
    };
    if (window.attachEvent) {
      window.attachEvent('onresize', onresize);
    } else if (window.addEventListener) {
      window.addEventListener('resize', onresize, true);
    }
    
    
    makeCurtains(document.querySelector('.stage.wrapper'), );
    </script>